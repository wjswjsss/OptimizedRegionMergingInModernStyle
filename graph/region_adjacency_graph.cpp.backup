/**
 * @file region_adjacency_graph.cpp
 * @brief Implementation of basic region merging algorithm
 * 
 * @author Claude
 * @date 2025
 */

#include "region_adjacency_graph.hpp"
#include <algorithm>
#include <cmath>
#include <unordered_set>

namespace region_merging {

// =============================================================================
// Construction
// =============================================================================

RegionAdjacencyGraph::RegionAdjacencyGraph(const PointCloud& cloud, 
                                           double radius)
    : num_vertices(static_cast<int>(cloud.size()))
    , num_edges(0)
    , search_radius(radius)
{
    std::cout << "Building Region Adjacency Graph..." << std::endl;
    std::cout << "  Points: " << num_vertices << std::endl;
    std::cout << "  Search radius: " << search_radius << std::endl;
    
    // Allocate vertices (one per point)
    vertices = std::make_unique<Vertex[]>(num_vertices);
    
    // Initialize vertices
    for (int i = 0; i < num_vertices; ++i) {
        const auto& point = cloud.points[i];
        vertices[i].init(i, point.position, point.normal);
    }
    
    std::cout << "  Initialized " << num_vertices << " vertices" << std::endl;
    
    // Build edges (connect nearby points)
    build_edges(cloud, search_radius);
    
    std::cout << "  Created " << num_edges << " edges" << std::endl;
    std::cout << "  Average degree: " << (2.0 * num_edges / num_vertices) << std::endl;
}

// =============================================================================
// Edge Construction
// =============================================================================

void RegionAdjacencyGraph::build_edges(const PointCloud& cloud, 
                                       double radius) {
    // First pass: count edges
    int edge_count = 0;
    std::vector<std::pair<int, int>> edge_list;  // Pairs of vertex IDs
    
    std::cout << "  Finding neighbors..." << std::flush;
    
    double radius_sq = radius * radius;  // Use squared distance (faster)
    
    // Brute force neighbor search: O(n²)
    // Future optimization: Use KD-tree for O(n log n)
    for (int i = 0; i < num_vertices; ++i) {
        for (int j = i + 1; j < num_vertices; ++j) {
            double dist_sq = distance_squared(
                cloud.points[i].position,
                cloud.points[j].position
            );
            
            if (dist_sq <= radius_sq) {
                edge_list.emplace_back(i, j);
                edge_count++;
            }
        }
        
        // Progress indicator for large datasets
        if ((i + 1) % 1000 == 0) {
            std::cout << "." << std::flush;
        }
    }
    std::cout << " done" << std::endl;
    
    // Allocate edges
    num_edges = edge_count;
    edges = std::make_unique<Edge[]>(num_edges);
    
    std::cout << "  Computing edge weights..." << std::flush;
    
    // Initialize edges
    for (int i = 0; i < num_edges; ++i) {
        int v1_id = edge_list[i].first;
        int v2_id = edge_list[i].second;
        
        Vertex* v1 = &vertices[v1_id];
        Vertex* v2 = &vertices[v2_id];
        
        // Compute weight (dissimilarity measure)
        double weight = compute_edge_weight(v1, v2);
        
        // Initialize edge
        edges[i].init(i, v1, v2, weight);
        
        // Add edge to both vertices' adjacency lists
        v1->add_edge(i);
        v2->add_edge(i);
        
        // Progress indicator
        if ((i + 1) % 10000 == 0) {
            std::cout << "." << std::flush;
        }
    }
    std::cout << " done" << std::endl;
}

// =============================================================================
// Weight Computation
// =============================================================================

double RegionAdjacencyGraph::compute_edge_weight(const Vertex* v1, 
                                                 const Vertex* v2) const {
    // Dissimilarity = geometric distance + weighted angle difference
    
    // 1. Euclidean distance between centroids
    double dist = distance(v1->position, v2->position);
    
    // 2. Angle between normals (in radians, range [0, π])
    double angle_diff = angle_between(v1->normal, v2->normal);
    
    // 3. Combined weight (lower = more similar)
    // Formula: dist + k * angle_diff
    // where k scales the angle contribution
    double weight = dist + ANGLE_WEIGHT * angle_diff;
    
    return weight;
}

// =============================================================================
// Main Algorithm
// =============================================================================

Vertex* RegionAdjacencyGraph::run(double threshold) {
    std::cout << "\nRunning region merging (threshold = " << threshold << ")..." << std::endl;
    
    // Build priority queue from all edges
    // Min-heap: smallest weight at top
    std::priority_queue<Edge*, 
                       std::vector<Edge*>, 
                       EdgeWeightComparator> pq;
    
    std::cout << "  Building priority queue..." << std::flush;
    for (int i = 0; i < num_edges; ++i) {
        if (edges[i].is_active()) {
            pq.push(&edges[i]);
        }
    }
    std::cout << " done (" << pq.size() << " edges)" << std::endl;
    
    // Main merging loop
    int merge_count = 0;
    int skipped_count = 0;
    
    std::cout << "  Merging..." << std::flush;
    
    while (!pq.empty()) {
        // Get minimum weight edge
        Edge* e = pq.top();
        pq.pop();
        
        // Skip if edge is no longer valid
        if (e->is_frozen()) {
            skipped_count++;
            continue;
        }
        
        // Check threshold
        if (e->weight > threshold) {
            std::cout << "\n  Stopped: edge weight (" << e->weight 
                     << ") exceeds threshold (" << threshold << ")" << std::endl;
            break;
        }
        
        // Get vertices (update to roots in case of previous merges)
        Vertex* v1 = e->left_vertex->find_root();
        Vertex* v2 = e->right_vertex->find_root();
        
        // Skip if already merged (self-loop)
        if (v1 == v2) {
            e->state = State::Frozen;
            skipped_count++;
            continue;
        }
        
        // Merge the vertices!
        v2->merge_into(v1);  // v1 becomes parent
        merge_count++;
        
        // Update affected edges and re-add to queue
        auto updated_edges = update_edges_after_merge(v1, v2);
        for (Edge* updated_edge : updated_edges) {
            if (updated_edge->is_active()) {
                pq.push(updated_edge);
            }
        }
        
        // Mark this edge as processed
        e->state = State::Frozen;
        
        // Progress indicator
        if (merge_count % 100 == 0) {
            std::cout << "." << std::flush;
        }
    }
    
    std::cout << " done" << std::endl;
    std::cout << "  Merges performed: " << merge_count << std::endl;
    std::cout << "  Edges skipped: " << skipped_count << std::endl;
    std::cout << "  Final segments: " << count_segments() << std::endl;
    
    // Return any active vertex (they're all in same connected component now)
    for (int i = 0; i < num_vertices; ++i) {
        if (vertices[i].is_active()) {
            return &vertices[i];
        }
    }
    
    return nullptr;  // All vertices merged? (shouldn't happen)
}

// =============================================================================
// Edge Update After Merge
// =============================================================================

std::vector<Edge*> RegionAdjacencyGraph::update_edges_after_merge(
    Vertex* merged_vertex,
    Vertex* removed_vertex) 
{
    std::vector<Edge*> updated_edges;
    
    // Process edges from removed_vertex
    for (EdgeID edge_id : removed_vertex->edge_ids) {
        Edge* e = &edges[edge_id];
        
        if (e->is_frozen()) continue;
        
        // Update edge endpoint to merged_vertex
        if (e->left_vertex == removed_vertex) {
            e->left_vertex = merged_vertex;
        } else if (e->right_vertex == removed_vertex) {
            e->right_vertex = merged_vertex;
        }
        
        // Update endpoints to roots
        e->left_vertex = e->left_vertex->find_root();
        e->right_vertex = e->right_vertex->find_root();
        
        // Check if it's now a self-loop
        if (e->left_vertex == e->right_vertex) {
            e->state = State::Frozen;
            continue;
        }
        
        // Check for duplicate edges
        Edge* duplicate = find_duplicate_edge(e);
        if (duplicate != nullptr && duplicate != e) {
            // Keep the edge with lower weight
            if (e->weight < duplicate->weight) {
                duplicate->state = State::Frozen;
            } else {
                e->state = State::Frozen;
                continue;
            }
        }
        
        // Add edge to merged_vertex's adjacency list (if not already there)
        if (!merged_vertex->edge_ids.empty()) {
            auto it = std::find(merged_vertex->edge_ids.begin(),
                              merged_vertex->edge_ids.end(),
                              edge_id);
            if (it == merged_vertex->edge_ids.end()) {
                merged_vertex->add_edge(edge_id);
            }
        } else {
            merged_vertex->add_edge(edge_id);
        }
        
        // Recompute weight (vertices have changed)
        e->weight = compute_edge_weight(e->left_vertex, e->right_vertex);
        
        // Add to updated list
        updated_edges.push_back(e);
    }
    
    return updated_edges;
}

// =============================================================================
// Helper Functions
// =============================================================================

bool RegionAdjacencyGraph::is_self_loop(const Edge* e) const {
    return e->left_vertex->find_root() == e->right_vertex->find_root();
}

Edge* RegionAdjacencyGraph::find_duplicate_edge(const Edge* e) const {
    Vertex* v1 = e->left_vertex;
    Vertex* v2 = e->right_vertex;
    
    // Search v1's edges for another edge connecting to v2
    for (EdgeID edge_id : v1->edge_ids) {
        const Edge* other = &edges[edge_id];
        
        if (other == e) continue;  // Skip self
        if (other->is_frozen()) continue;
        
        if (other->connects(v1, v2)) {
            return const_cast<Edge*>(other);
        }
    }
    
    return nullptr;
}

// =============================================================================
// Output Functions
// =============================================================================

std::vector<int> RegionAdjacencyGraph::get_segment_ids() const {
    std::vector<int> segment_ids(num_vertices);
    
    // Map root vertices to unique segment IDs
    std::unordered_map<const Vertex*, int> root_to_id;
    int next_id = 0;
    
    for (int i = 0; i < num_vertices; ++i) {
        const Vertex* root = vertices[i].find_root();
        
        // Assign new ID if not seen before
        if (root_to_id.find(root) == root_to_id.end()) {
            root_to_id[root] = next_id++;
        }
        
        segment_ids[i] = root_to_id[root];
    }
    
    return segment_ids;
}

int RegionAdjacencyGraph::count_segments() const {
    std::unordered_set<const Vertex*> unique_roots;
    
    for (int i = 0; i < num_vertices; ++i) {
        unique_roots.insert(vertices[i].find_root());
    }
    
    return static_cast<int>(unique_roots.size());
}

bool RegionAdjacencyGraph::save_segmentation(const std::string& filename,
                                             const PointCloud& original_cloud) const {
    auto segment_ids = get_segment_ids();
    return original_cloud.save_to_csv(filename, &segment_ids);
}

void RegionAdjacencyGraph::print_stats() const {
    int active_vertices = 0;
    int active_edges = 0;
    
    for (int i = 0; i < num_vertices; ++i) {
        if (vertices[i].is_active()) active_vertices++;
    }
    
    for (int i = 0; i < num_edges; ++i) {
        if (edges[i].is_active()) active_edges++;
    }
    
    std::cout << "\nGraph Statistics:" << std::endl;
    std::cout << "  Total vertices: " << num_vertices << std::endl;
    std::cout << "  Active vertices: " << active_vertices << std::endl;
    std::cout << "  Total edges: " << num_edges << std::endl;
    std::cout << "  Active edges: " << active_edges << std::endl;
    std::cout << "  Final segments: " << count_segments() << std::endl;
}

} // namespace region_merging
